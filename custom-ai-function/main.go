package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"

	"github.com/crossplane/crossplane-runtime/pkg/errors"
	"github.com/crossplane/crossplane-runtime/pkg/logging"
	fnv1beta1 "github.com/crossplane/function-sdk-go/proto/v1beta1"
	"github.com/crossplane/function-sdk-go/request"
	"github.com/crossplane/function-sdk-go/response"
)

// Function implements the Crossplane Function interface
type Function struct {
	fnv1beta1.UnimplementedFunctionRunnerServiceServer
	log logging.Logger
}

// AIPromptInput represents the input for AI processing
type AIPromptInput struct {
	APIVersion string `json:"apiVersion"`
	Kind       string `json:"kind"`
	Prompt     string `json:"prompt"`
	Provider   string `json:"provider"` // "openai" or "claude"
}

// RunFunction processes the AI prompt and generates infrastructure
func (f *Function) RunFunction(ctx context.Context, req *fnv1beta1.RunFunctionRequest) (*fnv1beta1.RunFunctionResponse, error) {
	f.log.Info("Processing AI function request")

	rsp := response.To(req, response.DefaultTTL)

	// Parse the input
	var input AIPromptInput
	if err := request.GetInput(req, &input); err != nil {
		response.Fatal(rsp, errors.Wrapf(err, "cannot get function input"))
		return rsp, nil
	}

	f.log.Info("Processing prompt", "provider", input.Provider, "prompt", input.Prompt)

	// Get API keys from environment
	var apiKey string
	switch input.Provider {
	case "openai":
		apiKey = os.Getenv("OPENAI_API_KEY")
		if apiKey == "" {
			response.Fatal(rsp, errors.New("OPENAI_API_KEY not found in environment"))
			return rsp, nil
		}
	case "claude":
		apiKey = os.Getenv("CLAUDE_API_KEY")
		if apiKey == "" {
			response.Fatal(rsp, errors.New("CLAUDE_API_KEY not found in environment"))
			return rsp, nil
		}
	default:
		response.Fatal(rsp, errors.Errorf("unsupported AI provider: %s", input.Provider))
		return rsp, nil
	}

	// Process the AI prompt (simplified example)
	resources, err := f.processAIPrompt(ctx, input.Prompt, input.Provider, apiKey)
	if err != nil {
		response.Fatal(rsp, errors.Wrapf(err, "failed to process AI prompt"))
		return rsp, nil
	}

	// Add generated resources to the response
	for _, resource := range resources {
		if err := response.SetDesiredComposedResource(rsp, resource); err != nil {
			response.Fatal(rsp, errors.Wrapf(err, "failed to set desired composed resource"))
			return rsp, nil
		}
	}

	f.log.Info("Successfully processed AI prompt", "resourceCount", len(resources))
	return rsp, nil
}

// processAIPrompt calls the AI API and generates Kubernetes resources
func (f *Function) processAIPrompt(ctx context.Context, prompt, provider, apiKey string) ([]map[string]interface{}, error) {
	// This is a simplified example - you would implement actual API calls here
	f.log.Info("Calling AI API", "provider", provider)

	// Example: Generate a Lambda function based on the prompt
	lambdaFunction := map[string]interface{}{
		"apiVersion": "lambda.aws.upbound.io/v1beta1",
		"kind":       "Function",
		"metadata": map[string]interface{}{
			"name": "ai-generated-function",
			"annotations": map[string]interface{}{
				"ai.msdp.com/generated-by": provider,
				"ai.msdp.com/prompt":       prompt,
			},
		},
		"spec": map[string]interface{}{
			"forProvider": map[string]interface{}{
				"region":  "eu-west-1",
				"runtime": "nodejs18.x",
				"handler": "index.handler",
				"role":    "arn:aws:iam::319422413814:role/lambda-execution-role",
				"code": map[string]interface{}{
					"zipFile": f.generateLambdaCode(prompt),
				},
			},
			"providerConfigRef": map[string]interface{}{
				"name": "default",
			},
		},
	}

	return []map[string]interface{}{lambdaFunction}, nil
}

// generateLambdaCode creates Lambda function code based on the AI prompt
func (f *Function) generateLambdaCode(prompt string) string {
	// This would use your actual AI API to generate code
	return fmt.Sprintf(`
const AWS = require('aws-sdk');

// Generated by AI based on prompt: %s
exports.handler = async (event) => {
    console.log('AI-generated function processing request');
    
    const response = {
        statusCode: 200,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'
        },
        body: JSON.stringify({
            message: 'AI-generated infrastructure is working!',
            prompt: '%s',
            timestamp: new Date().toISOString()
        })
    };
    
    return response;
};`, prompt, prompt)
}

func main() {
	// This would be your actual function server setup
	fmt.Println("Custom AI Function for Crossplane")
	fmt.Println("OpenAI API Key configured:", os.Getenv("OPENAI_API_KEY") != "")
	fmt.Println("Claude API Key configured:", os.Getenv("CLAUDE_API_KEY") != "")
}
